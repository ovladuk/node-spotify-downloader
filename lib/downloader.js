// Generated by CoffeeScript 1.10.0
(function() {
  var Downloader, EventEmitter, Logger, Path, Track, async, fixPathPiece, fs, lodash, spotifyWeb,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Logger = require("./log");

  Logger = new Logger();

  Track = require("./track");

  fixPathPiece = require("./util").fixPathPiece;

  fs = require("fs");

  async = require("async");

  lodash = require("lodash");

  spotifyWeb = require("spotify-web");

  EventEmitter = require("events").EventEmitter;

  Path = require('path');

  Downloader = (function(superClass) {
    extend(Downloader, superClass);

    function Downloader(config) {
      this.config = config;
      this.processTrack = bind(this.processTrack, this);
      this.handleDownload = bind(this.handleDownload, this);
      this.handleType = bind(this.handleType, this);
      this.login = bind(this.login, this);
      this.run = bind(this.run, this);
      this.fixPath = bind(this.fixPath, this);
      this.data = {
        trackCount: 0
      };
      this.Track = new Track();
    }

    Downloader.prototype.fixPath = function(path) {
      path = path.replace(/\//g, "-");
      if (this.config.onWindows) {
        path = fixPathPiece(path);
      }
      return path;
    };

    Downloader.prototype.run = function() {
      return async.series([this.login, this.handleType, this.handleDownload], (function(_this) {
        return function(err, res) {
          if (err) {
            Logger.Log("" + (res.toString()));
            return Logger.Error("" + (err.toString()));
          }
          Logger.Success(' ------- DONE ALL ------- ');
          return process.exit(0);
        };
      })(this));
    };

    Downloader.prototype.login = function(callback) {
      return spotifyWeb.login(this.config.username, this.config.password, (function(_this) {
        return function(err, SpotifyInstance) {
          if (err) {
            return Logger.Error("Error logging in... (" + err + ")");
          }
          Logger.Success("Login successful!");
          _this.spotify = SpotifyInstance;
          _this.Track.setSpotify(_this.spotify);
          return typeof callback === "function" ? callback() : void 0;
        };
      })(this));
    };

    Downloader.prototype.handleType = function(callback) {
      if (this.config.type === "playlist") {
        Logger.Log("Handling playlist ...");
        return this.spotify.playlist(this.config.uri, 0, 9001, (function(_this) {
          return function(err, data) {
            if (err) {
              return Logger.Error("Playlist data error... " + err);
            }
            Logger.Log("Playlist: " + data.attributes.name);
            _this.data.name = data.attributes.name;
            if (_this.config.folder === true || _this.config.folder === "") {
              _this.config.directory = Path.join(_this.config.directory, _this.fixPath(_this.data.name));
            }
            _this.data.tracks = lodash.map(data.contents.items, function(track) {
              _this.data.trackCount += 1;
              return track.uri;
            });
            return typeof callback === "function" ? callback() : void 0;
          };
        })(this));
      } else if (this.config.type === "album") {
        Logger.Log("Handling album ...");
        return this.spotify.get(this.config.uri, (function(_this) {
          return function(err, album) {
            var tracks;
            if (err) {
              return Logger.Error("Album data error... " + err);
            }
            Logger.Log("Album: " + album.name);
            _this.data.name = album.name;
            if (_this.config.folder === true || _this.config.folder === "") {
              _this.config.directory = Path.join(_this.config.directory, _this.fixPath(_this.data.name) + (" [" + album.date.year + "]/"));
            }
            tracks = [];
            album.disc.forEach(function(disc) {
              if (Array.isArray(disc.track)) {
                return tracks.push.apply(tracks, disc.track);
              }
            });
            _this.data.tracks = lodash.map(tracks, function(track) {
              _this.data.trackCount += 1;
              return track.uri;
            });
            return typeof callback === "function" ? callback() : void 0;
          };
        })(this));
      } else if (this.config.type === "track") {
        Logger.Log("Handling track ...");
        this.data.tracks = [this.config.uri];
        this.data.trackCount = 1;
        return typeof callback === "function" ? callback() : void 0;
      } else if (this.config.type === "library") {
        Logger.Log("Handling library ...");
        return this.spotify.library(this.config.username, 0, 9001, (function(_this) {
          return function(err, data) {
            if (err) {
              return Logger.Error("Library data error... " + err);
            }
            if (_this.config.folder === true || _this.config.folder === "") {
              _this.config.directory = Path.join(_this.config.directory, "Library/");
            }
            _this.data.tracks = lodash.map(data.contents.items, function(track) {
              _this.data.trackCount += 1;
              return track.uri;
            });
            return typeof callback === "function" ? callback() : void 0;
          };
        })(this));
      }
    };

    Downloader.prototype.handleDownload = function(callback) {
      Logger.Log("Processing " + this.data.trackCount + " tracks");
      return async.mapSeries(this.data.tracks, this.processTrack, callback);
    };

    Downloader.prototype.processTrack = function(uri, callback) {
      var uriType;
      uriType = spotifyWeb.uriType(uri);
      if (uriType === "local") {
        Logger.Info("Skipping Local Track: " + uri, 1);
        return typeof callback === "function" ? callback() : void 0;
      }
      return this.Track.process(uri, this.config, callback);
    };

    return Downloader;

  })(EventEmitter);

  module.exports = Downloader;

}).call(this);
